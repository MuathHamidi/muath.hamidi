<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Definitive Crystal Analysis Dashboard</title>
    <style>
        /* General dark theme styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #1a1a1a; /* Dark background */
            color: #e0e0e0; /* Light text */
            max-width: 1200px;
            margin: 20px auto;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); /* Darker shadow */
        }
        h1, h3 {
            color: #8ac8ff; /* A bright, contrasting blue for headings */
        }
        h1 {
            text-align: center;
            border-bottom: 2px solid #444; /* Darker border */
            padding-bottom: 10px;
        }

        /* Controls and Status */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        .button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }
        .button:hover {
            background-color: #0056b3;
        }
        #file-input, #folder-input {
            display: none;
        }
        #status-container {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #status {
            font-style: italic;
            color: #999; /* Lighter status text */
        }
        #spinner {
            border: 4px solid #333; /* Darker spinner base */
            border-top: 4px solid #007bff; /* Blue spinner top */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Results sections */
        #results {
            margin-top: 20px;
        }
        .result-file, #global-summary {
            margin-bottom: 15px;
            border: 1px solid #333; /* Darker border */
            border-radius: 5px;
        }
        .result-file summary, #global-summary summary {
            font-weight: bold;
            font-size: 1.1em;
            padding: 12px;
            cursor: pointer;
            background-color: #2c2c2c; /* Darker summary background */
        }
        .result-file[open] summary, #global-summary[open] summary {
            background-color: #3a3a3a; /* Slightly lighter on open */
            border-bottom: 1px solid #444;
        }
        .result-content {
            padding: 15px;
            display: grid;
            gap: 15px;
        }
        .error-file summary {
            background-color: #58151c; /* Darker red for errors */
            color: #fdd; /* Lighter text */
        }
        .stat-box {
            background-color: #2c2c2c; /* Darker box background */
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
        }

        /* Tables and code blocks */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        th {
            background-color: #3a3a3a; /* Darker table header */
            font-weight: 600;
        }
        code {
            background-color: #4a4a4a; /* Darker code background */
            padding: 2px 5px;
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }

        /* Heatmap and Tooltip */
        .heatmap-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }
        #global-heatmap-pt {
            cursor: crosshair;
            width: 100%;
            height: auto;
        }
        #global-heatmap-matrix {
            width: 100%;
            height: auto;
        }
        #heatmap-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none;
            display: none;
            z-index: 10;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <h1>Definitive Crystal Analysis Dashboard</h1>
    <p>Select multiple CIF files or a folder. This app generates a detailed report for each file and two aggregated global plots: an interactive Periodic Table Heatmap and a high-resolution Bond Matrix Heatmap.</p>
    <div id="controls">
        <label for="file-input" class="button">Select CIF File(s)</label>
        <input type="file" id="file-input" accept=".cif" multiple>
        <label for="folder-input" class="button">Select Folder</label>
        <input type="file" id="folder-input" webkitdirectory directory multiple>
        <button class="button" id="clear-btn" style="background-color: #6c757d;">Clear Results</button>
        <div id="status-container">
            <div id="spinner"></div>
            <div id="status">Ready to analyze.</div>
        </div>
    </div>
    <div id="results"></div>
    <div id="heatmap-tooltip"></div>

<script>
    const ELEMENT_DATA={'H':{t:'nonmetal',e:2.2,r:0.37,m:1.008,an:1},'He':{t:'noble gas',e:null,r:0.32,m:4.0026,an:2},'Li':{t:'metal',e:0.98,r:1.34,m:6.94,an:3},'Be':{t:'metal',e:1.57,r:0.9,m:9.0122,an:4},'B':{t:'metalloid',e:2.04,r:0.82,m:10.81,an:5},'C':{t:'nonmetal',e:2.55,r:0.77,m:12.011,an:6},'N':{t:'nonmetal',e:3.04,r:0.75,m:14.007,an:7},'O':{t:'nonmetal',e:3.44,r:0.73,m:15.999,an:8},'F':{t:'nonmetal',e:3.98,r:0.71,m:18.998,an:9},'Ne':{t:'noble gas',e:null,r:0.69,m:20.18,an:10},'Na':{t:'metal',e:0.93,r:1.54,m:22.99,an:11},'Mg':{t:'metal',e:1.31,r:1.3,m:24.305,an:12},'Al':{t:'metal',e:1.61,r:1.18,m:26.982,an:13},'Si':{t:'metalloid',e:1.9,r:1.11,m:28.085,an:14},'P':{t:'nonmetal',e:2.19,r:1.06,m:30.974,an:15},'S':{t:'nonmetal',e:2.58,r:1.02,m:32.06,an:16},'Cl':{t:'nonmetal',e:3.16,r:0.99,m:35.45,an:17},'Ar':{t:'noble gas',e:null,r:0.97,m:39.948,an:18},'K':{t:'metal',e:0.82,r:1.96,m:39.098,an:19},'Ca':{t:'metal',e:1.0,r:1.74,m:40.078,an:20},'Sc':{t:'metal',e:1.36,r:1.44,m:44.956,an:21},'Ti':{t:'metal',e:1.54,r:1.36,m:47.867,an:22},'V':{t:'metal',e:1.63,r:1.25,m:50.942,an:23},'Cr':{t:'metal',e:1.66,r:1.27,m:51.996,an:24},'Mn':{t:'metal',e:1.55,r:1.39,m:54.938,an:25},'Fe':{t:'metal',e:1.83,r:1.25,m:55.845,an:26},'Co':{t:'metal',e:1.88,r:1.26,m:58.933,an:27},'Ni':{t:'metal',e:1.91,r:1.21,m:58.693,an:28},'Cu':{t:'metal',e:1.9,r:1.38,m:63.546,an:29},'Zn':{t:'metal',e:1.65,r:1.31,m:65.38,an:30},'Ga':{t:'metal',e:1.81,r:1.26,m:69.723,an:31},'Ge':{t:'metalloid',e:2.01,r:1.22,m:72.63,an:32},'As':{t:'metalloid',e:2.18,r:1.19,m:74.922,an:33},'Se':{t:'nonmetal',e:2.55,r:1.16,m:78.971,an:34},'Br':{t:'nonmetal',e:2.96,r:1.14,m:79.904,an:35},'Kr':{t:'noble gas',e:3.0,r:1.1,m:83.798,an:36},'Rb':{t:'metal',e:0.82,r:2.11,m:85.468,an:37},'Sr':{t:'metal',e:0.95,r:1.92,m:87.62,an:38},'Y':{t:'metal',e:1.22,r:1.62,m:88.906,an:39},'Zr':{t:'metal',e:1.33,r:1.48,m:91.224,an:40},'Nb':{t:'metal',e:1.6,r:1.37,m:92.906,an:41},'Mo':{t:'metal',e:2.16,r:1.45,m:95.96,an:42},'Tc':{t:'metal',e:1.9,r:1.56,m:98,an:43},'Ru':{t:'metal',e:2.2,r:1.26,m:101.07,an:44},'Rh':{t:'metal',e:2.28,r:1.35,m:102.91,an:45},'Pd':{t:'metal',e:2.2,r:1.31,m:106.42,an:46},'Ag':{t:'metal',e:1.93,r:1.53,m:107.87,an:47},'Cd':{t:'metal',e:1.69,r:1.48,m:112.41,an:48},'In':{t:'metal',e:1.78,r:1.44,m:114.82,an:49},'Sn':{t:'metal',e:1.96,r:1.41,m:118.71,an:50},'Sb':{t:'metalloid',e:2.05,r:1.38,m:121.76,an:51},'Te':{t:'metalloid',e:2.1,r:1.35,m:127.6,an:52},'I':{t:'nonmetal',e:2.66,r:1.33,m:126.9,an:53},'Xe':{t:'noble gas',e:2.6,r:1.3,m:131.29,an:54},'Cs':{t:'metal',e:0.79,r:2.25,m:132.91,an:55},'Ba':{t:'metal',e:0.89,r:1.98,m:137.33,an:56},'La':{t:'metal',e:1.1,r:1.69,m:138.91,an:57},'Ce':{t:'metal',e:1.12,r:1.65,m:140.12,an:58},'Pr':{t:'metal',e:1.13,r:1.65,m:140.91,an:59},'Nd':{t:'metal',e:1.14,r:1.64,m:144.24,an:60},'Pm':{t:'metal',e:1.13,r:1.63,m:145,an:61},'Sm':{t:'metal',e:1.17,r:1.62,m:150.36,an:62},'Eu':{t:'metal',e:1.2,r:1.85,m:151.96,an:63},'Gd':{t:'metal',e:1.2,r:1.61,m:157.25,an:64},'Tb':{t:'metal',e:1.1,r:1.59,m:158.93,an:65},'Dy':{t:'metal',e:1.22,r:1.59,m:162.5,an:66},'Ho':{t:'metal',e:1.23,r:1.58,m:164.93,an:67},'Er':{t:'metal',e:1.24,r:1.57,m:167.26,an:68},'Tm':{t:'metal',e:1.25,r:1.56,m:168.93,an:69},'Yb':{t:'metal',e:1.1,r:1.74,m:173.05,an:70},'Lu':{t:'metal',e:1.27,r:1.56,m:174.97,an:71},'Hf':{t:'metal',e:1.3,r:1.5,m:178.49,an:72},'Ta':{t:'metal',e:1.5,r:1.38,m:180.95,an:73},'W':{t:'metal',e:2.36,r:1.46,m:183.84,an:74},'Re':{t:'metal',e:1.9,r:1.59,m:186.21,an:75},'Os':{t:'metal',e:2.2,r:1.28,m:190.23,an:76},'Ir':{t:'metal',e:2.2,r:1.37,m:192.22,an:77},'Pt':{t:'metal',e:2.28,r:1.28,m:195.08,an:78},'Au':{t:'metal',e:2.54,r:1.28,m:196.97,an:79},'Hg':{t:'metal',e:2.0,r:1.32,m:200.59,an:80},'Tl':{t:'metal',e:1.62,r:1.48,m:204.38,an:81},'Pb':{t:'metal',e:2.33,r:1.47,m:207.2,an:82},'Bi':{t:'metal',e:2.02,r:1.46,m:208.98,an:83},'Po':{t:'metalloid',e:2.0,r:1.46,m:209,an:84},'At':{t:'metalloid',e:2.2,r:1.45,m:210,an:85},'Rn':{t:'noble gas',e:2.2,r:1.45,m:222,an:86},'Fr':{t:'metal',e:0.7,r:2.23,m:223,an:87},'Ra':{t:'metal',e:0.9,r:2.01,m:226,an:88},'Ac':{t:'metal',e:1.1,r:1.86,m:227,an:89},'Th':{t:'metal',e:1.3,r:1.65,m:232.04,an:90},'Pa':{t:'metal',e:1.5,r:1.69,m:231.04,an:91},'U':{t:'metal',e:1.38,r:1.7,m:238.03,an:92},'Np':{t:'metal',e:1.36,r:null,m:237,an:93},'Pu':{t:'metal',e:1.28,r:null,m:244,an:94},'Am':{t:'metal',e:1.13,r:null,m:243,an:95},'Cm':{t:'metal',e:1.28,r:null,m:247,an:96},'Bk':{t:'metal',e:1.3,r:null,m:247,an:97},'Cf':{t:'metal',e:1.3,r:null,m:251,an:98},'Es':{t:'metal',e:1.3,r:null,m:252,an:99},'Fm':{t:'metal',e:1.3,r:null,m:257,an:100},'Md':{t:'metal',e:1.3,r:null,m:258,an:101},'No':{t:'metal',e:1.3,r:null,m:259,an:102},'Lr':{t:'metal',e:1.3,r:null,m:262,an:103},'Rf':{t:'metal',e:null,r:null,m:267,an:104},'Db':{t:'metal',e:null,r:null,m:270,an:105},'Sg':{t:'metal',e:null,r:null,m:271,an:106},'Bh':{t:'metal',e:null,r:null,m:270,an:107},'Hs':{t:'metal',e:null,r:null,m:277,an:108},'Mt':{t:'metal',e:null,r:null,m:276,an:109},'Ds':{t:'metal',e:null,r:null,m:281,an:110},'Rg':{t:'metal',e:null,r:null,m:282,an:111},'Cn':{t:'metal',e:null,r:null,m:285,an:112},'Nh':{t:'metal',e:null,r:null,m:286,an:113},'Fl':{t:'metal',e:null,r:null,m:289,an:114},'Mc':{t:'metal',e:null,r:null,m:290,an:115},'Lv':{t:'metal',e:null,r:null,m:293,an:116},'Ts':{t:'metalloid',e:null,r:null,m:294,an:117},'Og':{t:'noble gas',e:null,r:null,m:294,an:118}};
    const PERIODIC_TABLE_LAYOUT=[[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],[3,4,0,0,0,0,0,0,0,0,0,0,5,6,7,8,9,10],[11,12,0,0,0,0,0,0,0,0,0,0,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36],[37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54],[55,56,null,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86],[87,88,null,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,0],[0,0,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,0]];
    const AN_TO_SYM = Object.fromEntries(Object.entries(ELEMENT_DATA).map(([sym, data]) => [data.an, sym]));
    
    const fileInput=document.getElementById('file-input'),folderInput=document.getElementById('folder-input'),clearBtn=document.getElementById('clear-btn'),statusDiv=document.getElementById('status'),resultsDiv=document.getElementById('results'),spinner=document.getElementById('spinner'),tooltip=document.getElementById('heatmap-tooltip');
    fileInput.addEventListener('change',e=>handleFileSelection(e.target.files));folderInput.addEventListener('change',e=>handleFileSelection(e.target.files));clearBtn.addEventListener('click',()=>{resultsDiv.innerHTML='';statusDiv.textContent='Ready to analyze.';fileInput.value='';folderInput.value='';});
    async function handleFileSelection(files){const cifFiles=Array.from(files).filter(f=>f.name.toLowerCase().endsWith('.cif'));if(cifFiles.length===0){statusDiv.textContent='No .cif files selected.';return}resultsDiv.innerHTML='';spinner.style.display='block';let globalBondStats={};let analysisResults=[];for(const[index,file]of cifFiles.entries()){statusDiv.textContent=`Analyzing ${index+1} of ${cifFiles.length}: ${file.name}...`;const result=await processSingleFile(file);if(result.bondStats){result.bondStats.forEach(stat=>{const key=stat.pair;if(!globalBondStats[key])globalBondStats[key]=[];globalBondStats[key].push({avg:stat.avg,count:stat.count})})}analysisResults.push(result.html)}const globalHtml=formatGlobalSummaryHTML(cifFiles.length,globalBondStats);resultsDiv.innerHTML=globalHtml+analysisResults.join('');spinner.style.display='none';statusDiv.textContent=`Analysis complete. Processed ${cifFiles.length} file(s). Drawing plots...`;setTimeout(()=>{if(Object.keys(globalBondStats).length>0){drawGlobalInteractiveHeatmap(globalBondStats);drawGlobalMatrixHeatmap(globalBondStats);}},100);statusDiv.textContent=`Analysis and plotting complete.`}
    function processSingleFile(file){return new Promise(resolve=>{const reader=new FileReader();reader.onload=e=>{try{const cifContent=e.target.result;const{parsedData,warnings}=parseCIF(cifContent);const fullCellAtoms=generateSymmetricAtoms(parsedData.atoms,parsedData.symmOps);const bonds=analyzeStructure(parsedData.cell,fullCellAtoms);const stats=calculateGlobalStats(parsedData.cell,fullCellAtoms);const bondStats=calculateBondStats(bonds);resolve({html:formatResultHTML(file.name,stats,bondStats,warnings),bondStats})}catch(err){resolve({html:formatErrorHTML(file.name,err)})}};reader.onerror=()=>resolve({html:formatErrorHTML(file.name,new Error('Failed to read file.'))});reader.readAsText(file)})}
    
    function parseCIF(text){const lines=text.split('\n');const data={cell:{},atoms:[],symmOps:[]};let inAtomLoop=false,inSymmLoop=false,atomProps=[],symmProps=[];const warnings=new Set();const getValue=(key,lines)=>{const line=lines.find(l=>l.trim().startsWith(key));return line?parseFloat(line.split(/\s+/)[1].split('(')[0]):null;};data.cell.a=getValue('_cell_length_a',lines);data.cell.b=getValue('_cell_length_b',lines);data.cell.c=getValue('_cell_length_c',lines);data.cell.alpha=(getValue('_cell_angle_alpha',lines)||90)*(Math.PI/180);data.cell.beta=(getValue('_cell_angle_beta',lines)||90)*(Math.PI/180);data.cell.gamma=(getValue('_cell_angle_gamma',lines)||90)*(Math.PI/180);if(!data.cell.a||!data.cell.b||!data.cell.c)throw new Error("Could not parse unit cell lengths.");for(const line of lines){const trimmed=line.trim();if(trimmed.startsWith('loop_')){inAtomLoop=false;inSymmLoop=false;}else if(trimmed.startsWith('_atom_site_')){if(!inAtomLoop){inAtomLoop=true;inSymmLoop=false;atomProps=[];}atomProps.push(trimmed);}else if(trimmed.startsWith('_space_group_symop_operation_xyz')){if(!inSymmLoop){inSymmLoop=true;inAtomLoop=false;symmProps=[];}symmProps.push(trimmed);}else if(inAtomLoop&&trimmed&&!trimmed.startsWith('_')){const values=trimmed.split(/\s+/);const atom={};for(let i=0;i<atomProps.length;i++){const prop=atomProps[i];if(prop==='_atom_site_label')atom.label=values[i];if(prop==='_atom_site_type_symbol')atom.symbol=values[i];if(prop==='_atom_site_fract_x')atom.fx=parseFloat(values[i]);if(prop==='_atom_site_fract_y')atom.fy=parseFloat(values[i]);if(prop==='_atom_site_fract_z')atom.fz=parseFloat(values[i]);}if(!atom.symbol&&atom.label){atom.symbol=atom.label;}if(atom.symbol){let cleanSymbol=atom.symbol.replace(/[^A-Za-z]/g,'');atom.symbol=cleanSymbol.charAt(0).toUpperCase()+cleanSymbol.slice(1).toLowerCase();}if(atom.label&&atom.symbol&&atom.fx!==undefined){if(!ELEMENT_DATA[atom.symbol])warnings.add(atom.symbol);data.atoms.push(atom);}}else if(inSymmLoop&&trimmed&&!trimmed.startsWith('_')){const opString=trimmed.match(/'(.*?)'|(\S+,\s*\S+,\s*\S+)/);if(opString)data.symmOps.push(opString[1]||opString[2]);}}if(data.atoms.length===0)throw new Error("No atoms found in the CIF file's atom loop.");if(data.symmOps.length===0)data.symmOps.push('x, y, z');return{parsedData:data,warnings:Array.from(warnings)};}
    function parseSymOp(opStr){const parts=opStr.replace(/'/g,'').split(',').map(s=>s.trim());return(x,y,z)=>{const scope={x,y,z};const evalPart=part=>{const sanitized=part.replace(/([xyz])/g,'scope.$1');try{return new Function('scope',`return ${sanitized}`)(scope);}catch(e){throw new Error(`Could not parse symmetry op: "${part}"`);}};return{fx:evalPart(parts[0]),fy:evalPart(parts[1]),fz:evalPart(parts[2])};};}
    function generateSymmetricAtoms(asymAtoms,symmOps){const fullCellAtoms=[],uniquePositions=new Set(),symmFuncs=symmOps.map(op=>parseSymOp(op));asymAtoms.forEach(atom=>{symmFuncs.forEach((func,idx)=>{let{fx,fy,fz}=func(atom.fx,atom.fy,atom.fz);fx=(fx%1+1)%1;if(Math.abs(fx-1)<1e-4)fx=0;fy=(fy%1+1)%1;if(Math.abs(fy-1)<1e-4)fy=0;fz=(fz%1+1)%1;if(Math.abs(fz-1)<1e-4)fz=0;const posKey=`${atom.symbol}-${fx.toFixed(4)},${fy.toFixed(4)},${fz.toFixed(4)}`;if(!uniquePositions.has(posKey)){uniquePositions.add(posKey);fullCellAtoms.push({...atom,fx,fy,fz,label:`${atom.label}_s${idx+1}`});}});});return fullCellAtoms;}
    function analyzeStructure(cell,atoms){const ca=Math.cos(cell.alpha),cb=Math.cos(cell.beta),cg=Math.cos(cell.gamma);const m=[[cell.a,cell.b*cg,cell.c*cb],[0,cell.b*Math.sin(cell.gamma),cell.c*(ca-cb*cg)/Math.sin(cell.gamma)],[0,0,cell.a*cell.b*cell.c*Math.sqrt(1-ca*ca-cb*cb-cg*cg+2*ca*cb*cg)/(cell.a*cell.b*Math.sin(cell.gamma))]];const toCartesian=(fx,fy,fz)=>({x:m[0][0]*fx+m[0][1]*fy+m[0][2]*fz,y:m[1][1]*fy+m[1][2]*fz,z:m[2][2]*fz});const bonds=[];const tolerance=1.3;for(let i=0;i<atoms.length;i++){const atomA=atoms[i];const elA=ELEMENT_DATA[atomA.symbol];if(!elA||!elA.r)continue;for(let j=i;j<atoms.length;j++){const atomB=atoms[j];const elB=ELEMENT_DATA[atomB.symbol];if(!elB||!elB.r)continue;let shortestDist=Infinity;for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){if(i===j&&(dx===0&&dy===0&&dz===0))continue;let dfx=atomB.fx+dx-atomA.fx;let dfy=atomB.fy+dy-atomA.fy;let dfz=atomB.fz+dz-atomA.fz;const cartVec=toCartesian(dfx,dfy,dfz);const dist=Math.sqrt(cartVec.x**2+cartVec.y**2+cartVec.z**2);if(dist<shortestDist)shortestDist=dist;}const bondThreshold=(elA.r+elB.r)*tolerance;if(shortestDist>0.1&&shortestDist<bondThreshold){bonds.push({atom1:atomA,atom2:atomB,dist:shortestDist,type:determineBondType(elA,elB,atomA.symbol,atomB.symbol)});}}}return bonds;}
    function determineBondType(el1,el2,sym1,sym2){const type1=(ELEMENT_DATA[sym1]||{}).t;const type2=(ELEMENT_DATA[sym2]||{}).t;if(type1==='metal'&&type2==='metal')return'Metallic';const deltaEN=(el1.e!==null&&el2.e!==null)?Math.abs(el1.e-el2.e):null;if(deltaEN>1.8)return'Ionic';if(deltaEN<0.4)return'Nonpolar Covalent';return'Polar Covalent';}
    function calculateGlobalStats(cell,fullCellAtoms){const ca=Math.cos(cell.alpha),cb=Math.cos(cell.beta),cg=Math.cos(cell.gamma);const volume=cell.a*cell.b*cell.c*Math.sqrt(1-ca*ca-cb*cb-cg*cg+2*ca*cb*cg);const counts={};let totalMass=0;fullCellAtoms.forEach(atom=>{counts[atom.symbol]=(counts[atom.symbol]||0)+1;totalMass+=(ELEMENT_DATA[atom.symbol]||{m:0}).m;});const amu_to_g=1.66054e-24;const A3_to_cm3=1e-24;const density=(totalMass*amu_to_g)/(volume*A3_to_cm3);const composition=Object.entries(counts).map(([sym,count])=>{const mass=(ELEMENT_DATA[sym]||{m:0}).m*count;return{sym,count,massPercent:(mass/totalMass*100)};}).sort((a,b)=>b.massPercent-a.massPercent);return{volume,density,composition,counts};}
    function calculateBondStats(bonds){const stats={};bonds.forEach(bond=>{const key=[bond.atom1.symbol,bond.atom2.symbol].sort().join('-');if(!stats[key])stats[key]={pair:key,type:bond.type,dists:[]};stats[key].dists.push(bond.dist);});return Object.values(stats).map(s=>({...s,count:s.dists.length,min:Math.min(...s.dists),max:Math.max(...s.dists),avg:s.dists.reduce((a,b)=>a+b,0)/s.dists.length})).sort((a,b)=>b.count-a.count);}
    function getHeatmapColor(value,min,max){if(min>=max)return'rgb(0,255,0)';const t=(value-min)/(max-min);const r=Math.round(Math.max(0,255*(t*2-1)));const b=Math.round(Math.max(0,255*(1-t*2)));const g=255-b-r;return`rgb(${r},${g},${b})`;}
    
    function getAggregatedStats(globalBondStats) {
        const finalStats = {};
        for (const [pair, entries] of Object.entries(globalBondStats)) {
            let totalCount = 0; let weightedSum = 0;
            entries.forEach(entry => { totalCount += entry.count; weightedSum += entry.avg * entry.count; });
            if (totalCount > 0) finalStats[pair] = { avg: weightedSum / totalCount, count: totalCount };
        }
        return finalStats;
    }

    function drawGlobalInteractiveHeatmap(globalStats) {
        const canvas = document.getElementById('global-heatmap-pt'); if(!canvas) return;
        const ctx = canvas.getContext('2d'); const containerWidth = canvas.parentElement.clientWidth;
        const dpr = window.devicePixelRatio || 1; canvas.width = containerWidth * dpr; canvas.height = (containerWidth / 18) * 10 * dpr;
        canvas.style.width = `${containerWidth}px`; canvas.style.height = `${canvas.height / dpr}px`; ctx.scale(dpr, dpr);
        const finalGlobalStats = getAggregatedStats(globalStats);
        const numRows = PERIODIC_TABLE_LAYOUT.length, numCols = PERIODIC_TABLE_LAYOUT[0].length;
        const cellSize = (containerWidth-20) / numCols; const baseFontSize = cellSize * 0.5;

        const drawTable = (hoveredSym = null) => {
            ctx.clearRect(0, 0, canvas.width/dpr, canvas.height/dpr);
            let hoveredBonds = [], hoveredDists = [];
            if(hoveredSym) {
                Object.entries(finalGlobalStats).forEach(([pair, data]) => {
                    if (pair.split('-').includes(hoveredSym)) { hoveredBonds.push({pair, ...data}); hoveredDists.push(data.avg); }
                });
            }
            const minHoverDist = hoveredDists.length ? Math.min(...hoveredDists) : 0; const maxHoverDist = hoveredDists.length ? Math.max(...hoveredDists) : 0;

            PERIODIC_TABLE_LAYOUT.forEach((row, r) => {
                row.forEach((an, c) => {
                    if (an > 0) {
                        const sym = AN_TO_SYM[an]; let color = '#444444'; // Dark gray for inactive elements
                        if(hoveredSym) { const bond = hoveredBonds.find(b => b.pair.split('-').includes(sym)); if(bond) color = getHeatmapColor(bond.avg, minHoverDist, maxHoverDist); }
                        ctx.fillStyle = color; ctx.fillRect(c * cellSize + 5, r * cellSize + 5, cellSize - 1, cellSize - 1);
                        ctx.fillStyle = '#f0f0f0'; // Light text on dark background
                        ctx.font = `${baseFontSize}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(sym, c * cellSize + cellSize / 2 + 5, r * cellSize + cellSize / 2 + 5);
                    }
                });
            });
        };
        drawTable();
        canvas.onmousemove = (e) => {
            const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const c = Math.floor((x-5) / cellSize), r = Math.floor((y-5) / cellSize);
            if (r >= 0 && r < numRows && c >= 0 && c < numCols) {
                const an = PERIODIC_TABLE_LAYOUT[r][c];
                if (an > 0) {
                    const sym = AN_TO_SYM[an]; drawTable(sym);
                    let tooltipContent = `<b>${sym} (Z=${an}) - Avg Bond Distances</b><hr>`; let hasBonds = false;
                    Object.entries(finalGlobalStats).forEach(([pair, data]) => { if (pair.split('-').includes(sym)) { tooltipContent += `${pair}: ${data.avg.toFixed(3)} Å (total ${data.count} bonds)<br>`; hasBonds = true; } });
                    if (!hasBonds) tooltipContent += 'No bonds found in dataset.';
                    tooltip.innerHTML = tooltipContent; tooltip.style.left = `${e.pageX + 15}px`; tooltip.style.top = `${e.pageY + 15}px`; tooltip.style.display = 'block';
                } else { drawTable(); tooltip.style.display = 'none'; }
            } else { drawTable(); tooltip.style.display = 'none'; }
        };
        canvas.onmouseleave = () => { drawTable(); tooltip.style.display = 'none'; };
    }

    function drawGlobalMatrixHeatmap(globalStats) {
        const canvas = document.getElementById('global-heatmap-matrix'); if(!canvas) return;
        const ctx = canvas.getContext('2d'); const containerWidth = canvas.parentElement.clientWidth;
        const dpr = window.devicePixelRatio || 1; canvas.width = containerWidth * dpr; canvas.height = containerWidth * dpr;
        canvas.style.width = `${containerWidth}px`; canvas.style.height = `${containerWidth}px`; ctx.scale(dpr, dpr);

        const finalGlobalStats = getAggregatedStats(globalStats);
        const allSymbols = [...new Set(Object.keys(finalGlobalStats).flatMap(p => p.split('-')))].sort((a,b)=>ELEMENT_DATA[a].an - ELEMENT_DATA[b].an);
        const symbolMap = new Map(allSymbols.map((s, i) => [s, i]));
        const numSymbols = allSymbols.length; const labelOffset = 30;
        const cellSize = (containerWidth - labelOffset) / numSymbols;

        const allDists = Object.values(finalGlobalStats).map(s => s.avg);
        const minDist = Math.min(...allDists), maxDist = Math.max(...allDists);
        
        ctx.clearRect(0,0,containerWidth,containerWidth); ctx.font = `${Math.min(12, cellSize * 0.8)}px sans-serif`;
        ctx.fillStyle = '#e0e0e0'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

        allSymbols.forEach((s, i) => {
            if(numSymbols < 40 || i % (numSymbols < 80 ? 5 : 10) === 0) {
                ctx.fillText(s, labelOffset + (i + 0.5) * cellSize, labelOffset / 2);
                ctx.save();
                ctx.translate(labelOffset / 2, labelOffset + (i + 0.5) * cellSize);
                ctx.rotate(-Math.PI/2); ctx.fillText(s, 0, 0);
                ctx.restore();
            }
        });

        Object.entries(finalGlobalStats).forEach(([pair, data]) => {
            const [sym1, sym2] = pair.split('-');
            const i = symbolMap.get(sym1), j = symbolMap.get(sym2);
            const color = getHeatmapColor(data.avg, minDist, maxDist);
            ctx.fillStyle = color;
            ctx.fillRect(labelOffset + j * cellSize, labelOffset + i * cellSize, cellSize, cellSize);
            if (i !== j) ctx.fillRect(labelOffset + i * cellSize, labelOffset + j * cellSize, cellSize, cellSize);
        });

        const legend = document.getElementById('global-heatmap-matrix-legend-canvas');
        if (!legend) return;
        const legendCtx = legend.getContext('2d');
        const grad = legendCtx.createLinearGradient(0, 0, legend.width, 0);
        grad.addColorStop(0, getHeatmapColor(minDist, minDist, maxDist));
        grad.addColorStop(0.5, getHeatmapColor((minDist+maxDist)/2, minDist, maxDist));
        grad.addColorStop(1, getHeatmapColor(maxDist, minDist, maxDist));
        legendCtx.fillStyle = grad;
        legendCtx.fillRect(0, 0, legend.width, legend.height);
        document.getElementById('global-heatmap-matrix-legend-min').textContent = `${minDist.toFixed(2)} Å`;
        document.getElementById('global-heatmap-matrix-legend-max').textContent = `${maxDist.toFixed(2)} Å`;
    }

    function formatGlobalSummaryHTML(fileCount, globalStats) {
        if (Object.keys(globalStats).length === 0) return '';
        const aggregatedStats = getAggregatedStats(globalStats);
        const sortedPairs = Object.entries(aggregatedStats).sort(([, a], [, b]) => b.count - a.count);
        
        const bondStatsTable = `
            <details class="stat-box" open>
                <summary><h3>Aggregated Bond Statistics</h3></summary>
                <p>Total count of each bond type across all analyzed files.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Pair</th>
                            <th>Total Count</th>
                            <th>Avg Dist (Å)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedPairs.map(([pair, data]) => `
                            <tr>
                                <td><b>${pair}</b></td>
                                <td>${data.count}</td>
                                <td>${data.avg.toFixed(3)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </details>
        `;

        return `
        <details id="global-summary" open>
            <summary>Overall Analysis Summary (${fileCount} Files)</summary>
            <div class="result-content">
                ${bondStatsTable}
                <details class="stat-box"><summary><h3>Interactive Periodic Table Heatmap</h3></summary><p>Hover over an element to highlight its average bond distances to all other elements found in the dataset.</p><div class="heatmap-container"><canvas id="global-heatmap-pt"></canvas></div></details>
                <details class="stat-box"><summary><h3>High-Resolution Bond Matrix Heatmap</h3></summary><p>Overall average bond distances for all pairs found across all analyzed files.</p><div class="heatmap-container"><canvas id="global-heatmap-matrix"></canvas><div class="heatmap-legend"><span id="global-heatmap-matrix-legend-min"></span><canvas id="global-heatmap-matrix-legend-canvas" width="200" height="20" style="border:1px solid #ccc;"></canvas><span id="global-heatmap-matrix-legend-max"></span></div></div></details>
            </div>
        </details>`;
    }
    function formatResultHTML(filename, stats, bondStats, warnings) {
        const formula = Object.entries(stats.counts).map(([sym,c])=>`${sym}${c}`).join('');
        return `
        <details class="result-file">
            <summary>${filename} (${formula})</summary>
            <div class="result-content">
                ${warnings.length > 0 ? `<div style="background-color:#4d3700;color:#ffc107;padding:15px;border-radius:5px;"><strong>Data Warning:</strong> Elements not found in internal database: <strong>${warnings.join(', ')}</strong>.</div>` : ''}
                <div class="stats-grid">
                    <div class="stat-box"><h3>Global Statistics</h3><ul><li><b>Formula:</b> ${formula}</li><li><b>Atoms in Cell:</b> ${Object.values(stats.counts).reduce((a, b) => a + b, 0)}</li><li><b>Cell Volume:</b> ${stats.volume.toFixed(3)} Å³</li><li><b>Density (ρ):</b> ${stats.density.toFixed(3)} g/cm³</li></ul></div>
                    <div class="stat-box"><h3>Elemental Composition</h3><table><thead><tr><th>Element</th><th>Count</th><th>Mass %</th></tr></thead><tbody>${stats.composition.map(c => `<tr><td>${c.sym}</td><td>${c.count}</td><td>${c.massPercent.toFixed(2)}%</td></tr>`).join('')}</tbody></table></div>
                </div>
                <details class="stat-box"><summary><h3>Bond Statistics</h3></summary><table><thead><tr><th>Pair</th><th>Count</th><th>Type</th><th>Min/Max/Avg Dist (Å)</th></tr></thead><tbody>${bondStats.map(s => `<tr><td><b>${s.pair}</b></td><td>${s.count}</td><td>${s.type}</td><td>${s.min.toFixed(3)} / ${s.max.toFixed(3)} / ${s.avg.toFixed(3)}</td></tr>`).join('')}</tbody></table></details>
            </div>
        </details>`;
    }
    function formatErrorHTML(filename, error) { return `<details class="result-file error-file" open><summary>Error: ${filename}</summary><div class="result-content"><p><strong>Could not analyze this file.</strong></p><p><strong>Reason:</strong> ${error.message}</p></div></details>`; }
</script>
</body>
</html>
